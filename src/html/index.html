<html>
<head>
	<meta charset="utf-8"></meta>
	<meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
	<meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>

	<!-- META TAGS TO PREVENT BROWSER CACHING OF THIS HTML FILE -->
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<!-- END OF META TAGS FOR CACHING -->

	<meta name="description" content=""></meta>
	<meta name="author" content=""></meta>
	<link rel="shortcut icon" type="image/png" href="images/favicon.png"></link>

	<title>web书签</title>

	<link rel="stylesheet" type="text/css" href="//lib.baomitu.com/iview/3.4.2/styles/iview.css">
	<script type="text/javascript" src="//lib.baomitu.com/vue/2.6.10/vue.min.js"></script>
	<script type="text/javascript" src="//lib.baomitu.com/iview/3.4.2/iview.min.js"></script>
	<script type="text/javascript" src="js/index.min.js"></script>
	<link rel="stylesheet" type="text/css" href="css/index.css">
</head>

<body>
<div id="app">
	<div class="my-search">
		<!-- MODIFIED Token Button END -->
		<span class="my-search-text">搜索：</span>
		<auto-complete
				v-model="query"
				icon="ios-search"
				v-on:input="handleSearch(query)"
				placeholder="按标题搜索"　style="width:70%">
			<div class="my-search-auto-complete-item" v-for="item in data" :key="item.url">
				<div class="my-search-auto-complete-group">
					<span><a :href='item.url'  target='_blank' rel='noreferrer'>{{ item.title }}</a></span>
				</div>
			</div>
		</auto-complete>
		<span class="my-zan" v-on:click="showewm" title="赞助一下"><i class="ivu-icon ivu-icon-md-heart-outline" style="font-size: 22px;"></i></span>
		<span class="my-reload" v-on:click="clearSessionCacheAndReload" title="清除缓存并重新加载"><i class="ivu-icon ivu-icon-md-refresh" style="font-size: 22px;"></i></span>
		<span class="my-token" v-on:click="openTokenModal" title="GitHub Token 设置"><i class="ivu-icon ivu-icon-ios-key-outline" style="font-size: 22px;"></i></span>
	</div>
	<div>
		<ul>
			<li v-for="(line, index) in arrRoot" :key="line.name + '-' + index" class="ivu-card ivu-card-bordered my-card" :style="{display:line.display}">
				<div v-if="!line.roothtml" class="ivu-card-head my-root-color ">正在加载{{line.name}}。。。</div>
				<div v-if="!!line.roothtml" class="ivu-card-head my-root-color ">{{line.name}}</div>
				<div v-if="!!line.roothtml" v-html="line.roothtml" :data-index="index" @click="buildDirHtmlProxy"></div>
			</li>
		</ul>
	</div>

	<!-- GitHub Token Modal -->
	<Modal
			v-model="showTokenModal"
			title="GitHub 个人访问令牌"
			@on-ok="saveToken"
			@on-cancel="closeTokenModal">
		<p>当前令牌: <strong>{{ currentTokenDisplay }}</strong></p>
		<Input v-model="inputToken" type="password" placeholder="输入您的 GitHub PAT" style="margin-top: 10px; margin-bottom: 10px;"/>
		<p>
			<Button type="error" @click="clearTokenInModal" :disabled="!apitoken">清除令牌</Button>
		</p>
		<div style="font-size: 0.9em; margin-top:15px; color: #777;">
			<p>GitHub 个人访问令牌 (PAT) 可用于提高 API 速率限制或访问私有仓库。</p>
			<p>您的令牌存储在浏览器的 <code>localStorage</code> 中，并随请求发送到 GitHub。</p>
			<p><a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens" target="_blank" rel="noopener noreferrer">如何创建 PAT</a>。所需权限范围取决于您的需求 (例如，私有仓库需要 `repo` 权限)。</p>
		</div>
	</Modal>
</div>
<script>
	var vm = new Vue({
        el: '#app',
        data(){
            return {
                 ops:{apiuser:"https://api.github.com/users/",
                         apirepos:"https://api.github.com/repos/",
                         download:"https://raw.githubusercontent.com/",
                         name:"justlovemaki",
                         path:"favorites",
                         reps:"my-favorites",
                         libs:"root",
                         showkeyurl:'',
                         dir:'',
                         infos:''
                         },
                    arrRoot: [],
                    query: '',
                    data: [],
                    showkey: '89757',
                    apitoken:null,
                    showTokenModal: false,
                    inputToken: ''
            }
        },
        computed: {
            currentTokenDisplay() {
                if (this.apitoken) {
                    if (this.apitoken.length > 8) {
                        return `${this.apitoken.substring(0, 4)}...${this.apitoken.substring(this.apitoken.length - 4)}`;
                    }
                    return '令牌已设置 (简略)';
                }
                return '未设置';
            }
        },
        created(){
            this.loadTokenFromStorage();

            var pns = location.pathname.split('/');
            pns = pns.filter(p => p !== "");

            if(pns[0] === this.ops.path){
                pns.splice(0,1);
            }

            this.ops.name = pns[0] || this.ops.name;
            this.ops.reps = pns[1] || this.ops.reps;
            this.ops.libs = pns[2] || this.ops.libs;

            this.ops.dir = `${this.ops.apirepos}${this.ops.name}/${this.ops.reps}/contents/${this.ops.libs}`;
            this.ops.infos = `${this.ops.apiuser}${this.ops.name}`;
            this.ops.showkeyurl = `${this.ops.apirepos}${this.ops.name}/${this.ops.reps}/contents/showkey`;
            console.log("Effective Ops:", this.ops);

            this.fetchUserInfos();
            this.fetchUserDir();
            this.fetchShowkey();
        },
        methods: {
        	appendTimestampToUrl(url) {
                if (!url) return url;
                const timestamp = Date.now();
                if (url.includes('?')) {
                    return `${url}&_t=${timestamp}`;
                } else {
                    return `${url}?_t=${timestamp}`;
                }
            },
            buildDirHtmlProxy(event) {
                buildDirHtml(event);
            },
            loadTokenFromStorage() {
                const storedToken = localStorage.getItem('githubApiToken');
                if (storedToken) {
                    this.apitoken = storedToken;
                    console.log("Token loaded from localStorage.");
                } else {
                    console.log("No token found in localStorage.");
                }
            },
            openTokenModal() {
                this.inputToken = ''; // Clear previous input
                this.showTokenModal = true;
            },
            saveToken() {
                let tokenChanged = false;
                const trimmedInputToken = this.inputToken.trim();

                if (trimmedInputToken) {
                    if (this.apitoken !== trimmedInputToken) {
                        this.apitoken = trimmedInputToken;
                        localStorage.setItem('githubApiToken', this.apitoken);
                        tokenChanged = true;
                        this.$Message.success('令牌保存成功！');
                    } else {
                         this.$Message.info('令牌与当前设置相同。');
                    }
                } else { // Empty input means clear the token
                    if (this.apitoken !== null) { // Only clear if there was a token
                        this.apitoken = null;
                        localStorage.removeItem('githubApiToken');
                        tokenChanged = true;
                        this.$Message.success('令牌清除成功！');
                    } else {
                        this.$Message.info('令牌仍未设置。');
                    }
                }
                this.inputToken = ''; // Clear input field after processing
                this.showTokenModal = false;

                if (tokenChanged) {
                    this.reloadDataDueToTokenChange();
                }
            },
            closeTokenModal() {
                this.inputToken = ''; // Clear input field if modal is cancelled
                this.showTokenModal = false;
            },
            clearTokenInModal() {
                if (this.apitoken) {
                    this.apitoken = null;
                    localStorage.removeItem('githubApiToken');
                    this.inputToken = ''; // Also clear the input field in the modal
                    this.$Message.success('令牌清除成功！');
                    // No need to close modal here, user might want to enter a new one
                    // Or they can click OK/Cancel
                    this.reloadDataDueToTokenChange();
                } else {
                    this.$Message.info('令牌本就未设置。');
                }
            },
            reloadDataDueToTokenChange() {
                this.$Notice.info({ title: '令牌配置已更改', desc: '正在重新加载数据，请稍候...' });

                // Clear session storage for .md files as their fetch might now succeed/fail differently
                if (this.arrRoot && this.arrRoot.length > 0) {
                    this.arrRoot.forEach(item => {
                        if (item.name && item.name.endsWith('.md')) {
                            sessionStorage.removeItem(item.name);
                            console.log(`已清除 ${item.name} 的会话缓存`);
                        }
                    });
                }

                this.arrRoot = []; // Reset main data
                this.data = []; // Reset search data

                // Re-fetch all data
                this.fetchUserInfos();
                this.fetchUserDir();
                this.fetchShowkey();
            },
            // New method to clear session cache and reload data
            clearSessionCacheAndReload() {
                this.$Notice.info({ title: '清除缓存', desc: '正在清除会话缓存并重新加载所有数据，请稍候...' });

                let itemsClearedCount = 0;
                if (this.arrRoot && this.arrRoot.length > 0) {
                    this.arrRoot.forEach(item => {
                        if (item.name && item.name.endsWith('.md')) {
                            if (sessionStorage.getItem(item.name)) { // Check if item actually exists in cache
                                sessionStorage.removeItem(item.name);
                                console.log(`已清除 ${item.name} 的会话缓存`);
                                itemsClearedCount++;
                            }
                        }
                    });
                }
                // Also clear general sessionStorage items if any were set outside arrRoot loop
                // For example, if a key "lastVersion" was stored: sessionStorage.removeItem("lastVersion");

                if (itemsClearedCount > 0) {
                    this.$Message.success(`已从会话存储中清除 ${itemsClearedCount} 个缓存项。`);
                } else {
                    this.$Message.info('会话存储中未找到可清除的缓存项，或数据尚未加载。');
                }

                // Reset data structures
                this.arrRoot = [];
                this.data = []; // For search results

                // Re-fetch all data - A full page reload is more robust for clearing all states
                // this.fetchUserInfos();
                // this.fetchUserDir();
                // this.fetchShowkey();
                window.location.reload(true); // Force reload from server, bypassing browser cache for the page itself
            },
            async fetchUserInfos(){
                const url = this.appendTimestampToUrl(this.ops.infos);
                const options = { headers: {} };
                if (this.apitoken) {
                    options.headers['Authorization'] = `token ${this.apitoken}`;
                }
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        let errorPayload = { message: `获取用户信息错误: ${response.status}` };
                        try {
                            const errorBody = await response.json();
                            errorPayload = { ...errorPayload, ...errorBody }; // Overwrite message if GitHub provides one
                        } catch (e) { /* ignore if error body is not JSON */ }
                        console.error("获取用户信息出错:", errorPayload);
                        throw new Error(errorPayload.message);
                    }
                    const data = await response.json();
                    console.log("用户信息:", data);
                    document.title = data.login + "的web书签";
                } catch (error) {
                    console.error(error.message);
                    document.title = "用户加载失败 - web书签";
                     this.$Message.error(`加载用户信息失败: ${error.message.substring(0,100)}`);
                }
            },
            async fetchShowkey(){
                const requestUrl = this.appendTimestampToUrl(this.ops.showkeyurl);
                const options = { headers: {} };
                let downloadUrl = null;

                if (this.apitoken) {
                    options.headers['Authorization'] = `token ${this.apitoken}`;
                }

                try {
                    const metaResponse = await fetch(requestUrl, options);
                    if (!metaResponse.ok) {
                        let errorText = `获取Showkey元数据错误: ${metaResponse.status}`;
                         try {
                            const errorBody = await metaResponse.json();
                            errorText = errorBody.message || errorText; // Use GitHub's message if available
                        } catch (e) { /* ignore */ }
                        throw new Error(errorText);
                    }
                    const metaData = await metaResponse.json();
                    if (!metaData.download_url) {
                        throw new Error("Showkey元数据响应中未找到download_url。");
                    }
                    downloadUrl = this.appendTimestampToUrl(metaData.download_url);

                    // Fetch actual content (no auth needed for raw.githubusercontent usually, but keep if PAT is for private repo content)
                    const contentOptions = {}; // Separate options for content fetch if needed
                    // if (this.apitoken && downloadUrl.includes("raw.githubusercontent.com") && isPrivateRepoScenario) {
                    //    contentOptions.headers = {'Authorization': `token ${this.apitoken}`};
                    // } // Typically not needed for raw content URL from public repo
                    const contentResponse = await fetch(downloadUrl, contentOptions);
                    if (!contentResponse.ok) {
                        let errorText = `获取Showkey内容错误: ${contentResponse.status}`;
                         try {
                            const bodyText = await contentResponse.text(); // Try to get more info
                            if (bodyText) errorText += ` - ${bodyText.substring(0,100)}`;
                        } catch (e) { /* ignore */ }
                        throw new Error(errorText);
                    }
                    const data = await contentResponse.text();
                    console.log("Showkey data raw:", data);
                    this.showkey = data.trim();
                } catch (error) {
                    console.error("获取showkey出错:", error.message);
                    // this.$Message.warning(`无法加载showkey: ${error.message.substring(0,100)}。将使用默认值。`);
                }
            },
            async fetchUserDir(){
                this.arrRoot = []; // Clear previous directory listing
                const requestUrl = this.appendTimestampToUrl(this.ops.dir);
                const options = { headers: {} };

                if (this.apitoken) {
                    options.headers['Authorization'] = `token ${this.apitoken}`;
                }

                try {
                    const response = await fetch(requestUrl, options);
                    if (!response.ok) {
                        let errorPayload = { message: `获取用户目录错误: ${response.status} (URL: ${requestUrl})` };
                         try {
                            const errorBody = await response.json();
                            // Prefer GitHub's error message if available
                            errorPayload.message = errorBody.message ? `获取用户目录错误: ${errorBody.message}` : errorPayload.message;
                            errorPayload = { ...errorPayload, ...errorBody };
                        } catch (e) { /* ignore if error body is not JSON */ }
                        console.error("获取用户目录出错:", errorPayload);
                        throw new Error(errorPayload.message);
                    }
                    const dirData = await response.json();
                    console.log("用户目录数据:", dirData);

                    if (Array.isArray(dirData)) {
                        dirData.forEach(line => {
                            if (line.type === 'file' && line.name.endsWith('.md')) {
                                const cacheItem = sessionStorage.getItem(line.name);
                                if (!!cacheItem) {
                                    try {
                                        const parsedCache = JSON.parse(cacheItem);
                                        this.arrRoot.push(parsedCache);
                                        console.log("从缓存取marks--" + line.name);
                                    } catch (e) {
                                        console.warn("解析缓存 " + line.name + " 失败, 重新获取。", e);
                                        sessionStorage.removeItem(line.name); // Remove corrupted cache
                                        const initObj = { text: line.download_url, name: line.name, list: null, roothtml: null, display: 'block' };
                                        getMd(line.name, this.appendTimestampToUrl(line.download_url), this, initObj);
                                    }
                                } else {
                                    const initObj = { text: line.download_url, name: line.name, list: null, roothtml: null, display: 'block' };
                                    getMd(line.name, this.appendTimestampToUrl(line.download_url), this, initObj);
                                }
                            } else if (line.type !== 'file') {
                                 console.log(`项目 '${line.name}' 是一个目录或符号链接，不由 getMd 处理。`);
                            } else if (!line.name.endsWith('.md')) {
                                 console.log(`项目 '${line.name}' 不是 Markdown 文件，不由 getMd 处理。`);
                            }
                        });
                         if (dirData.length === 0) {
                            this.$Message.info("目录为空或不包含 Markdown 文件。");
                        }
                    } else if (dirData.message) { // Handle cases where GitHub API returns an error object directly (e.g. rate limit)
                        console.error("用户目录数据返回错误对象:", dirData.message);
                        this.arrRoot.push({
                            name: "目录加载错误",
                            roothtml: `<div class='my-error-message'>加载目录失败: ${dirData.message}</div>`,
                            display: 'block'
                        });
                         this.$Message.error(`加载目录失败: ${dirData.message}`);
                    }
                    else { // Unexpected format
                        console.error("用户目录数据非数组格式:", dirData);
                        this.arrRoot.push({
                            name: "目录加载错误",
                            roothtml: "<div class='my-error-message'>加载目录结构失败。内容格式不符合预期。</div>",
                            display: 'block'
                        });
                        this.$Message.error("加载目录失败：非预期的数据格式。");
                    }
                } catch (error) { // Catch network errors or errors thrown from !response.ok
                    console.error(error.message);
                    this.arrRoot = [{
                        name: "加载目录出错，私有仓库请在搜索栏右侧填写token", // More generic user-facing title
                        roothtml: `<div class='my-error-message'>无法加载目录: ${error.message}</div>`,
                        display: 'block'
                    }];
                    this.$Message.error(`加载目录失败: ${error.message.substring(0,100)}`);
                }
            },
            handleSearch (value) {
                this.data = (!value || !value.trim()) ? [] : serachMarks(value.trim(), this.arrRoot);
                if(value === this.showkey){ // Show all if showkey is entered
                    this.arrRoot.forEach(function(obj) {
                        if(obj) obj.display='block';
                    });
                }
            },
            showewm(){ // "ewm" likely means "二维码" (QR code)
                this.$Modal.success({
                    title: '觉得赞的话，赞助一下呗！',
                    content: '<img src="images/pickme.jpg"  alt="二维码" />',
                    okText: '谢谢'
                });
            }
        }
    });
</script>
</body>
</html>